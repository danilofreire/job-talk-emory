---
title: Introduction to Custom Functions in Python
subtitle: Because copy-pasting code is so last semester
date: 2025-02-07
date-format: "MMMM DD, YYYY"
author:
  - name: Danilo Freire
    email: danilo.freire@emory.edu
    affiliations: "Emory University <br><br> <https://danilofreire.github.io/job-talk-emory/lecture.html>"
format:
  clean-revealjs:
    self-contained: true
    code-overflow: wrap
    footer: "[Python Functions](https://danilofreire.github.io/job-talk-emory/lecture.html)"
    drop:
      button: true
      engine: pyodide
      pyodide:
        packages:
          - matplotlib
          - micropip
          - numpy
          - pandas
          - seaborn
bibliography: references.bib
transition: slide
transition-speed: default
scrollable: true
engine: jupyter
revealjs-plugins:
  - drop
  - fontawesome
  - multimodal
editor:
  render-on-save: true
---

# Hello, everyone! <br> Nice to see you all! üòâ {background-color="#2d4563"}

## Lecture outline

:::{style="margin-top: 40px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
- [Why Functions?]{.alert .alert-primary}
    - Code Repetition & DRY principle

- [What are Functions?]{.alert .alert-primary}
    - Reusable Blocks (`def`)

- [Function Syntax]{.alert .alert-primary}
    - Anatomy & Examples

- [Function Arguments]{.alert .alert-primary}
    - Positional, Keyword, Default

- [Lambda Functions]{.alert .alert-primary}
    - Anonymous, One-liners

- [Variable Scope]{.alert .alert-primary}
    - Local & Global Scope

- [Best Practices & Pitfalls]{.alert .alert-primary}
    - Naming, Docstrings, Indentation, `return`

- [Summary & Q\&A]{.alert .alert-primary}
    - Recap & Next Steps
:::

:::{.column width="50%"}
:::{style="text-align: center; margin-top: -20px;"}
![](figures/hulk_antman_meme.png){width=80%}
:::
:::
:::
:::

# Let's get started! üöÄ {background-color="#2d4563"}

# Why functions? {background-color="#2d4563"}

## Why functions?

:::{style="margin-top: 40px; font-size: 27px;"}
:::{.columns}
:::{.column width="50%"}
:::{style="margin-top: 10px;"}
- The problem: [code repetition]{.alert} is a trap!
  - Imagine writing _the same_ code...
  - ... again and again and again! üò©
:::

:::{style="margin-top: 10px;"}
- An example: greeting many people
  -  Imagine doing this for 1000 names!
:::

:::{style="margin-top: 10px;"}
-  [Error-prone updates]{.alert}
-  [Hard to read]{.alert} and maintain
-  [Not efficient]{.alert} at all! üê¢
:::
:::

:::{.column width="50%"}
:::{style="text-align: center; margin-top: 20px;"}
```python
# Greeting people (without functions)
# Don't do this at home!

print("Nice to meet you, Alice!")
print("Nice to meet you, Bob!")
print("Nice to meet you, Charlie!")
print("Nice to meet you, Danilo!")
print("Nice to meet you, Emily!")
print("Nice to meet you, Frank!")
print("Nice to meet you, George!")

# ... repeats 993 more times ...
```

:::{.fragment}
[Maybe there's a better way to do this?]{.alert} ü§î
:::

:::
:::
:::
:::

## Functions to the rescue! ü¶∏‚Äç‚ôÇÔ∏è
### The best way to greet people (and much more!)

:::{style="margin-top: 40px"}
:::{.columns}
:::{.column width="50%"}
:::{style="font-size: 21px;"}
- Functions are like [mini-programs]{.alert}:
  - Self-contained blocks of code
  - Designed to perform a [specific task]{.alert}

- ["Recipes" for code:]{.alert} üßë‚Äçüç≥
    -  You define the steps (code inside the function)
    -  You can "call" the function (use the recipe) whenever you need it

- [You know them already!]{.alert}
  - `print()`, `type()`, `np.mean()`, `plt.hist()` are all functions you've used before! ü§ì

- Why are they useful?
    - [Reusable code]{.alert}
    - [Organised logic]{.alert} 
    - [One change updates all]{.alert} 
:::
:::

:::{.column width="50%"}
:::{style="text-align: center; margin-top: 20px; font-size: 24px;"}
```{python}
#| echo: true
#| eval: true
# Greeting people (with functions)
# Much better!

def greet(your_name):
    print(f"Nice to meet you, {your_name}!")

greet("Alice")
greet("Bob")
greet("Danilo")
```

:::{.fragment}
[DRY principle]{.alert}: [Don't Repeat Yourself](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) üòâ
:::

:::
:::
:::
:::

## Anatomy of a Python function
### The building blocks

:::{style="margin-top: 30px; font-size: 22px;"}
- Writing a function is like writing a sentence: [it requires some structure!]{.alert} ü§ìüìö

:::{style="text-align: center; margin-top: 10px;"}
![](figures/function-anatomy.png){width=35%}
:::

:::{.columns}
:::{.column width="50%"}
:::{.incremental}
1. [`def` keyword]{.alert}. Tells Python: "We are defining a function now"
2. [Function Name]{.alert} (`function_name`). Choose a descriptive name (e.g., `greet`, `calculate_age`, etc)
3. [Parentheses `()`]{.alert}. Enclose inputs the function needs. Empty `()` means no inputs
4. [Parameter(s) (optional)]{.alert} (`parameter`). A placeholder for the values the function will receive. Can be multiple, separated by commas
:::
:::

:::{.column width="50%"}
:::{.incremental}
5. [Argument(s) (optional)]{.alert} (`parameter=argument`). The actual values that will be passed to the function. 
6. [Colon `:`]{.alert} Ends the function header.  Don't forget it!
7. [Function Body]{.alert}. Code to execute. [After four spaces!]{.alert}
8. [`return` statement (optional)]{.alert}. What the function sends back.  If absent, function returns `None`. [Indent it too!]{.alert}
:::
:::
:::
:::

## Let's see some examples together üõ†Ô∏è
### Hello, Alice and Bob!

:::{style="margin-top: 30px; font-size: 22px;"}
- [Function with one parameter]{.alert}: `say_greeting(name)`

```{python}
#| echo: true
#| eval: true
def say_greeting(name):
    print(f"Hello, {name}! Nice to see you.")
```

:::{style="margin-top: 10px;"}
- [Think about it]{.alert}:
  - Can you identify the parts we discussed?
  - Does it have a `return` statement?
  - What if we store the output in a variable, like `message_alice = say_greeting("Alice")`?
:::

:::{style="margin-top: 10px; font-size: 24px;"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
say_greeting("Alice")
```
:::
:::

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
message_alice = say_greeting("Alice")
```
:::
:::

:::{.column width="50%"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
type(message_alice)
```
:::
:::
:::
:::
:::

## Let's see some examples together üõ†Ô∏è
### Hello, Alice and Bob!

:::{style="margin-top: 30px; font-size: 22px;"}
- And what about this one?

```{python}
#| echo: true
#| eval: true
def get_greeting(name, greeting_type="Hello"):
    message = f"{greeting_type}, {name}! Nice to see you."
    return message
```

:::{style="margin-top: 10px;"}
:::

- [Think about it]{.alert}:
  - How is this function different from `say_greeting`?
  - What about the `greeting_type="Hello"` part? What does it mean?
  - What if you run: `message_bob = get_greeting("Bob")` and then `print(message)`?

:::{style="margin-top: 10px;"}
:::

:::{.columns}
:::{.column width="50%"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
# No errors and no output!
message_bob = get_greeting("Bob")
```
:::

:::{style="margin-top: 10px;"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
type(message_bob)
```
:::
:::
:::

:::{.column width="50%"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
print(message_bob)
```
:::

:::{style="margin-top: 10px;"}
:::

:::{.fragment}
[We can use the result in further calculations!]{.alert}

More about the return statement [here](https://realpython.com/python-return-statement/)
:::
:::
:::
:::

## Passing arguments to functions
### Positional vs keyword arguments

:::{style="margin-top: 30px; font-size: 22px;"}
:::{.columns}
:::{.column width="60%"}
- We pass arguments to functions to make them [flexible]{.alert}
- There are two ways to pass arguments: [positional]{.alert} and [keyword]{.alert} arguments
- Positional arguments are passed in [the order the parameters are defined]{.alert}
- Let's see an example:

:::{style="margin-top: 30px;"}
:::

:::{.fragment}

```{python}
#| echo: true
#| eval: true
def get_greeting(name, greeting_type="Hello"):
    message = f"{greeting_type}, {name}! Nice to see you."
    return message

message = get_greeting("Alice", "Hi")
print(message)
```
:::
:::

:::{.column width="40%"}
:::{style="text-align: center; margin-top: -10px;"}
![Positional arguments](figures/positional.png)

:::{.fragment}
- What happens if you switch the order of the arguments?
:::

:::{.fragment}
```{python}
#| echo: true
#| eval: true
message = get_greeting("Hi", "Alice")
print(message)
```

[Order matters!]{.alert} üö®
:::
:::
:::
:::
:::

## Keyword arguments

:::{style="margin-top: 20px; font-size: 24px;"}
- If you use [keyword arguments]{.alert}, you can pass arguments by name in any order üòâ
- This is useful when you have [many arguments or default values]{.alert}, so you don't need to remember which ones come first

:::{style="margin-top: 20px;"}
```{python}
#| echo: true
#| eval: true
message = get_greeting(greeting_type="Hi", name="Alice")
print(message)
```
:::

:::{style="margin-top: 20px;"}
- Now it works just fine! üéâ

- The same is true for many functions you use often:
  
```{python}
#| echo: true
#| eval: true
import numpy as np

# Default order: loc, scale, size. But you can use keywords!
vector = np.random.normal(size = 4, loc = 10, scale = 2)
print(vector)
```

- [So far, so good?]{.alert} ü§ì
:::
:::

## Let's create a function together üõ†Ô∏è {#sec:rectangle}

:::{style="margin-top: 30px; font-size: 24px;"}
- Time to put our knowledge to the test! üöÄ
- Let's create a function that [calculates the area of a rectangle]{.alert}
- Please complete the `calculate_area` function below üëá

:::{style="margin-top: 20px;"}
```python
def calculate_area(_____, _____):   # What parameters do we need?
    # Function body - calculate the area
    ____ = _____ * _____           # How do we calculate area? Assign to 'area' variable
    return ____                    # What should the function return?
```
:::

:::{style="margin-top: 20px;"}
:::

:::{.fragment}
- Done? Then, call the function with `length=5` and `width=4`, and print the result
:::

:::{.fragment}
```python
result = calculate_area(length=5, width=4)    # Call with arguments
print(result)                                # Check if it's correct!
```
:::

:::{style="margin-top: 30px;"}
- [[Click here to see the solution]{.button}](#sec:appendix01)
:::
:::

## Another one? ü§ì
### Oops, something may be wrong here!

:::{style="margin-top: 30px; font-size: 22px;"}
:::{.columns}
:::{.column width="50%"}
- This function is [almost]{.alert} identical to the previous one
- It looks fine, right? Try to run it and see what happens!

```{python}
#| echo: true
#| eval: false
def greet_incorrect(greeting_type="Hello", name):
    message = f"{greeting_type}, {name}!"
    return message
```

- What's the error message? üö®

:::{style="margin-top: 20px;"}
:::{.fragment}
```{python}
#| eval: false
#| echo: true
  Cell In[14], line 1
    def greet_incorrect(greeting_type="Hello", name): 
                                               ^
SyntaxError: parameter without a default follows parameter with a default
```
:::
:::
:::

:::{.column width="50%"}
:::{.fragment}
- [What went wrong?]{.alert}
  - Python requires [non-default arguments first]{.alert}
  - [Fix it]{.alert} by moving `name` before `greeting_type`
  - I told you that [order matters]{.alert}! üòÇ
:::

:::{style="margin-top: 20px;"}
:::{.fragment}
- Let's fix it together:
  
```{python}
#| echo: true
#| eval: true
def greet_correct(name, greeting_type="Hello"):
    message = f"{greeting_type}, {name}!"
    return message

message = greet_correct("Alice", "Hi")
print(message)
```
:::
:::
:::
:::
:::

# Phew, that was a lot! {background-color="#2d4563"}

# Questions? ü§î {background-color="#2d4563"}

# Lambda (anonymous) functions üïµüèΩ‚Äç‚ôÄÔ∏è {background-color="#2d4563"}

## Lambda functions

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- Sometimes you don't need a full function definition
- Just a simple, [one-line function is enough]{.alert}
- Ô∏è[Lambda functions]{.alert} are perfect for this!
  - They can have many arguments but only one expression (no `return` statement)
  - They are also known as [anonymous functions]{.alert}, but can be assigned to a variable
- Syntax: `lambda arguments: expression`
  - `lambda x, y: x + y`
:::

:::{.column width="50%"}
:::{.fragment}
- Let's calculate `x + y + z` using a lambda function:
- Similar to writing a regular function, but in one line!

```{python}
#| echo: true
#| eval: true
sum_function = lambda x, y, z: x + y + z

result = sum_function(1, 2, 3)
print(result)
```
:::

:::{.fragment}
- [Easy, right?]{.alert}
- Now have a look at this ü§Ø

```{python}
#| echo: true
#| eval: true
result = (lambda x, y, z: x + y + z)(1, 2, 3)
print(result)
```
:::
:::
:::
:::

## Try it yourself! üõ†Ô∏è {#sec:exercise02}
### NASA needs your help! üöÄ

:::{style="margin-top: 30px; font-size: 26px;"}
- [Exercise]{.alert}: Create a lambda function that calculates `travel_distance` using the formula `speed * time`
- Use the lambda function to calculate the distance for `speed = 100` and `time = 2`
- Print the result

<br>

- [[Click here to see the solution]{.button}](#sec:appendix02)
:::

# Great job, everyone! üéâ {background-color="#2d4563"}

# Global vs local variables üåç {background-color="#2d4563"}

## Local variables
### What happens inside functions stays inside functions! ü§´

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- Python has a concept called [variable scope]{.alert}
- Scope means: [Where in your code can you use a variable?]{.alert} ü§î

:::{style="margin-top: 10px;"}
:::
- First, let's understand [local variables]{.alert}:
    - They are called local because [they are "local" to the function]{.alert}
    - They only exist and can be used [within that function's body]{.alert}
    - They are [not accessible from outside]{.alert} the function

- Think of it like a [private workspace]{.alert .alert-primary}:
    - But once the function finishes, that workspace (and its local variables) disappears! 

:::

:::{.column width="50%"}
:::{style="font-size: 23px;"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
def my_function():
    # message is a local variable
    message = "Hello from inside the function!"
    print(message)

# This works!
my_function() 
```
:::

:::{style="margin-top: 10px;"}
:::

:::{.fragment}
- Try to access `message` from outside:

```{python}
#| eval: false
#| echo: true
print(message) # Error!
```

:::{style="margin-top: 10px;"}
```{python}
#| eval: false
#| echo: true
NameError: name 'message' is not defined
```
:::
:::

:::{.fragment}
- `message` has disappeared!
- [Is it clear why?]{.alert} ü§ì
:::
:::
:::
:::
:::

## Global variables
### The world is your oyster (but use them sparingly!) üåç

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- Now, let's look at [global variables]{.alert}:
    - Variables defined [outside of any function]{.alert} (at the top level of your code) are called [global variables]{.alert}
    - They can be accessed from [anywhere]{.alert} in your code, including inside functions!

- Think of it like [shared information]{.alert .alert-primary} for your whole program:
    - Any part of your code can see and use global variables
:::

:::{.column width="50%"}
:::{style="font-size: 19px;"}
:::{.fragment}
```{python}
#| echo: true
#| eval: true
# 'global_greeting' is defined outside
global_greeting = "Welcome" 

# Accessing global variable inside
def greet_function(name):
    print(f"{global_greeting} {name}") 

greet_function("Alice") # Works fine!
print(global_greeting)   # Works fine outside too!
```
:::

:::{.fragment}
- [What happens if you try to change a global variable inside a function?]{.alert}

```{python}
#| eval: true
#| echo: true
global_greeting = "Welcome"

def change_greeting(new_greeting):
    global_greeting = new_greeting

change_greeting("Hello!") # No error!
print(global_greeting)    # But it doesn't change!
```
:::

:::{.fragment}
- [What's going on here?]{.alert}
:::
:::
:::
:::
:::

## The `global` keyword
### When you need to change a global variable inside a function

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- If you want to [change a global variable inside a function]{.alert}, you need to use the `global` keyword
- This tells Python: "Hey, I'm talking about the [global variable]{.alert} here!"

- Let's see an example:

```{python}
#| echo: true
#| eval: true
global_greeting = "Welcome!"

def change_greeting(new_greeting):
    global global_greeting
    global_greeting = new_greeting

change_greeting("Hello!")
print(global_greeting) # Now it works!
```
:::

:::{.column width="50%"}
:::{style="font-size: 24px;"}
:::{.fragment}
- That's why we need to be careful about using global variables inside functions
- They can make your code [hard to understand]{.alert} and [debug]{.alert}
- Did you notice how `global_greeting` is [not passed as an argument]{.alert} to the function?
- And yet we can [change its value]{.alert} inside the function!
:::

:::{.fragment}
- [So beware!]{.alert} üö®
:::
:::
:::
:::
:::

# Best practices and pitfalls üöß {background-color="#2d4563"}

## Best practices
### How to write better functions

:::{style="margin-top: 30px; font-size: 24px;"}
- Python has a [style guide]{.alert} called [PEP 8]{.alert} ([link here](https://peps.python.org/pep-0008/))
- It provides [best practices]{.alert} for writing clean, readable code
- Here are [some tips for writing better functions]{.alert}
- Including some I have learnt the hard way (don't ask me how)! üòÖ

:::{style="margin-top: 20px;"}
:::
- [Naming conventions]{.alert}:
    - Use [descriptive names]{.alert} for functions and variables
    - [snake_case]{.alert} for functions and variables ([camelCase]{.alert} is fine too)
    - Avoid [special characters]{.alert} and [reserved words]{.alert} (e.g., `$`, `@`, `print`, `sum`, `list`)

:::{style="margin-top: 20px;"}
:::
- Bad: `def f(x):`, `def function1():`, `def sum():`, `def cR@zY_fUnC():` üëé
- Good: `def calculate_area():`, `def greet_user():`, `def download_wbi():` üëç
:::

## Best practices
### Use `docstrings` to document your functions! üìö

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- [Docstrings]{.alert} are [multi-line comments]{.alert} that describe what your function does
- They are [enclosed in triple quotes]{.alert} (`"""` or `'''`)
- They should include:
    - [Function purpose]{.alert}
    - [Parameters]{.alert} and [return values]{.alert}
    - [Additional information]{.alert} if needed
- They help others (and you!) understand your code
- [Good documentation]{.alert} is a great way to ensure your code is [maintainable]{.alert}
:::

:::{.column width="50%"}
:::{style="font-size: 23px; margin-top: 10px;"}
```{python}
#| echo: true
#| eval: false
def calculate_area(length, width):
    """
    Calculate the area of a rectangle.

    Parameters:
    length (int): The length of the rectangle.
    width (int): The width of the rectangle.

    Returns:
    int: The area of the rectangle.
    """
    area = length * width
    return area
```

- That's beautiful, isn't it? üòÑ
:::
:::
:::
:::

## Pitfalls to avoid! üöß
### Indentation errors, missing `return`, and more!

:::{style="margin-top: 30px; font-size: 22px;"}
:::{.columns}
:::{.column width="50%"}
- You all know that Python is [indentation-sensitive]{.alert}
- It's not to make your code look pretty, but to [define the structure]{.alert} of your code
- [Incorrect indentation = `IndentationError`!]{.alert}
  - Python will complain loudly if your indentation is wrong üòÖ

:::{style="margin-top: 20px;"}
:::
:::{.fragment}
- [Common mistake 1]{.alert}: Forgetting to indent the function body

```{python}
#| eval: false
#| echo: true
# No indentation!
def my_function():
print("Hello!")

# Good code!
def my_function():
    print("Hello!")
```
:::
:::

:::{.column width="50%"}
:::{.fragment}
- [Common mistake 2]{.alert}: Incorrect number of spaces

```{python}
#| eval: false
#| echo: true
# Bad code! 2 spaces
def my_function():
  print("Hello!")

# Good code! 4 spaces!
def my_function():
    print("Hello!")
```
:::

:::{.fragment}
- [Common mistake 3]{.alert}: Mixing spaces and tabs

```{python}
#| eval: false
#| echo: true
# Mixing spaces and tabs
def my_function():
        print("Using a tab for indent")
    print("Using spaces")

# Good code! Use spaces only!
def my_function():
    print("Using spaces")
```
:::
:::
:::
:::

## Pitfalls to avoid! üöß
### Return and print: Know the difference! ü§î

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- [Return]{.alert} and [print]{.alert} are not the same!
- [Return]{.alert} sends a value back to the caller
- [Print]{.alert} displays a value on the screen

:::{style="margin-top: 20px;"}
:::
- [Common mistake 1]{.alert}: Using `print` instead of `return`

```{python}
#| eval: false
#| echo: true
def double(x):
    print(x * 2)

# Good code! Use return!
def double(x):
    return x * 2
```
:::

:::{.column width="50%"}
:::{.fragment}
- [Common mistake 2]{.alert}: Forgetting to `return` a value when you need one

```{python}
#| eval: false
#| echo: true
def double(x):
    x * 2

# Good code! Don't forget to return!
def double(x):
    return x * 2
```
:::

:::{.fragment}
- [Common mistake 3]{.alert}: Using one `return` inside a loop or `if` statement

```{python}
#| eval: false
#| echo: true
# No return statement for false?
def is_even(number):
    if number % 2 == 0:
        return True

# Good code! Return outside the if statement
def is_even(number):
    if number % 2 == 0:
        return True
    return False
```
:::
:::
:::
:::

# Summary üìö {background-color="#2d4563"}

## Summary

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
- [Functions]{.alert} are [mini-programs]{.alert} that perform a specific task
- They help you [avoid code repetition]{.alert} and keep your code [clean]{.alert}

:::{style="margin-top: 10px;"}
:::
- [Function anatomy]{.alert}:
    - `def` keyword, name, parameters, body, `return`, and indentation
    - [Positional vs keyword arguments]{.alert}
    - [Default values]{.alert}

:::{style="margin-top: 10px;"}
:::
- [Global vs local variables]{.alert}:
    - Local variables are only accessible inside the function
    - Global variables can be accessed from anywhere
    - Use `global` keyword to change global variables inside functions
:::

:::{.column width="50%"}
- [Best practices]{.alert}:
    - Naming conventions
    - Docstrings
    - Indentation
    - Return vs print

:::{style="margin-top: 10px;"}
:::

- [Pitfalls to avoid]{.alert}:
  - Indentation errors
  - Missing `return` statements
  - Global vs local variables
  - Using `print` instead of `return`
  - Using `return` inside loops or `if` statements
  - Mixing spaces and tabs
:::
:::
:::

# But wait, there's more! üòÖ {background-color="#2d4563"}

## Further reading

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- Some readings you may find useful:
  - [Python Functions](https://realpython.com/defining-your-own-python-function/)
  - [Python Lambda Functions](https://realpython.com/python-lambda/)
  - [Python Scope and the LEGB Rule](https://realpython.com/python-scope-legb-rule/)
  - [PEP 8 - Style Guide for Python Code](https://pep8.org/)
  - [Python Docstrings](https://realpython.com/documenting-python-code/)

- Online courses:
  - [Coursera](https://www.coursera.org/courses?query=python)
  - [edX](https://www.edx.org/learn/python)
  - [Udemy](https://www.udemy.com/courses/search/?q=python)
  - [Codecademy](https://www.codecademy.com/learn/learn-python-3)
  - [DataCamp](https://www.datacamp.com/courses/intro-to-python-for-data-science)
:::

:::{.column width="50%"}
:::{style="text-align: center; margin-top: 20px;"}
![](figures/python-def.webp){width=80%}
:::
:::
:::
:::

# Thank you very much! üôè {background-color="#2d4563"}

# ...and we're back! üòÑ {background-color="#2d4563"}

# Current and prospective courses {background-color="#2d4563"}

## QTM 151 - Introduction to Statistical Computing II
### Data Analysis with Python and SQL

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="40%"}
- The course introduces students to data analysis with Python and SQL
- It covers:
  - Data manipulation with Pandas and NumPy
  - Data visualisation with Matplotlib
  - Writing and running functions
  - Time series and panel data analysis
  - Introduction to SQL for data retrieval
  - Jupyter Notebooks and reproducible research

- All materials are free and openly available
:::

:::{.column width="60%"}
:::{style="text-align: center; margin-top: 20px;"}
![Click on the image to see the website](figures/qtm151.png){width=80% data-modal-type="iframe" data-modal-url="https://danilofreire.github.io/qtm151/"}

Course website: <https://danilofreire.github.io/qtm151/>
:::
:::
:::
:::

## QTM 350 - Data Science Computing
### Modern Data Science and Engineering

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="40%"}
- The course introduces students to modern data science and engineering, focusing on reliability, reproducibility, and robustness
- The course covers:
  - Command line interfaces
  - Version control with git and GitHub (using the terminal) 
  - Literate programming with Quarto
  - AI-assisted programming
  - Introduction to cloud computing
  - Data storage and retrieval with SQL
  - Parallel computing with Dask
  - Containers and reproducible workflows with Docker
  
- All materials are also free and openly available
:::

:::{.column width="60%"}
:::{style="text-align: center; margin-top: 20px;"}
![Click on the image to see the website](figures/qtm350.png){width=80% data-modal-type="iframe" data-modal-url="https://danilofreire.github.io/qtm350/"}

Course website: <https://danilofreire.github.io/qtm350/>
:::
:::
:::
:::

## QTM 385 - Experimental Methods
### 

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="40%"}
- QTM 385 is a course on experimental methods in the social and health sciences
- The main topics covered are:
  - The logic of causal inference
  - Randomisation procedures
  - Blocking and clustering
  - Pre-analysis plans and registered reports
  - Power calculations
  - Non-compliance and attrition
  - Survey experiments
  - Research ethics
  
- As with the other courses, all materials are available online
:::

:::{.column width="60%"}
:::{style="text-align: center; margin-top: 20px;"}
![Click on the image to see the website](figures/qtm385.png){width=80% data-modal-type="iframe" data-modal-url="https://danilofreire.github.io/qtm385/"}

Course website: <https://danilofreire.github.io/qtm385/>
:::
:::
:::
:::

## Suggested Course: Small Language Models
### How to build and fine-tune your own SLMs

:::{style="margin-top: 30px; font-size: 22px;"}
- Small Language Models are more useful than we think:
  - Efficient: Run on local machines, minimal GPU
  - Customisable: Tailor-made for your specific needs
  - Controlled:  Understand and influence model behaviour
  - Accessible: Lower cost, increased privacy

- Hands-on learning with practical skills:
    -  No complex setups, just your laptop and open-source tools
    -  Focus on real-world applications and contributing to the community
    - Based on the [Hugging Face ecosystem](https://huggingface.co/learn) (`transformers`, `trl`, `datasets`), [SMoLM2](https://github.com/huggingface/smol-course), and [ollama](https://ollama.com/)
:::

## Suggested Course: Small Language Models
### How to build and fine-tune your own SLMs

:::{style="margin-top: 30px; font-size: 22px;"}
- Key topics covered:

:::{style="margin-top: 10px;"}
:::

- [Instruction tuning](https://github.com/yaodongC/awesome-instruction-dataset)
    - Continue training the model on [instruction-following datasets](https://huggingface.co/datasets?search=instruction) instead of pre-trained data

- Preference alignment with [Direct Preference Optimisation (DPO)](https://arxiv.org/abs/2305.18290)
  - Train the model to [rank responses](https://huggingface.co/datasets/Anthropic/hh-rlhf) based on human preferences

- [Parameter-efficient fine-tuning](https://arxiv.org/abs/2312.12148)
  - Tune only a [small number of parameters](https://huggingface.co/blog/peft) and freeze the rest

- [Synthetic datasets](https://huggingface.co/datasets?search=synthetic) with [`distilabel`](https://distilabel.argilla.io/latest/)
  - Generate your own datasets to create your own [instruction-following models](https://huggingface.co/datasets?search=instruction)

- [Vision-language models](https://huggingface.co/blog/vlms)
  - Train models to [understand images and text](https://distilabel.argilla.io/latest/) together

- [Draft syllabus here](https://github.com/danilofreire/job-talk-emory/blob/main/syllabus.pdf)
:::

# Questions? {background-color="#2d4563"}

# Thanks again! üòÉ {background-color="#2d4563"}

## Appendix 01: Area of a rectangle {#sec:appendix01}

:::{style="margin-top: 30px; font-size: 24px;"}
- Here's the solution to the exercise:

```{python}
#| echo: true
#| eval: true
def calculate_area(length, width):
    area = length * width
    return area

result = calculate_area(5, 4)
print(result)
```

[[Back to the function]{.button}](#sec:rectangle)
:::

## Appendix 02: Travel distance {#sec:appendix02}

:::{style="margin-top: 30px; font-size: 24px;"}
- Here's the solution to the exercise:

```{python}
#| echo: true
#| eval: true
travel_distance = lambda speed, time: speed * time

distance = travel_distance(100, 2)
print(f"The distance is: {distance}")
```

- Or:

```{python}
#| echo: true
#| eval: true
distance = (lambda speed, time: speed * time)(100, 2)
print(f"The distance is: {distance}")
```

[[Back to the function]{.button}](#sec:exercise02)
:::

## Appendix 03: Nested functions {#sec:appendix03}

:::{style="margin-top: 30px; font-size: 24px;"}
:::{.columns}
:::{.column width="50%"}
- You can also define functions inside other functions:
- This is called a [nested function]{.alert}
- They work like regular functions, but are [only accessible inside the outer function]{.alert}
:::

:::{.column width="50%"}
```{python}
#| echo: true
#| eval: true
def outer_function(x):
    def inner_function(y):
        return x + y
    return inner_function(5)
```

- Here we are using the [inner function]{.alert} to [add 5 to x]{.alert}
- [Pretty cool, right?]{.alert} ü§ì
:::
:::
:::

## Appendix 04: Functions with `for` loops {#sec:appendix04}

:::{style="margin-top: 30px; font-size: 24px;"}
- You can also use `for` loops inside functions
- They're useful when you need to [repeat a task multiple times]{.alert}

```{python}
#| echo: true
#| eval: true
def sum_list(numbers):
    """
    Calculates the sum of numbers in a list.
    """
    total = 0
    for number in numbers:
        total += number
    return total

# Example usage:
numbers = [1, 2, 3, 4, 5]
result = sum_list(numbers)
print(result)
```
:::

## Appendix 05: LEGB rule {#sec:appendix05}

:::{style="margin-top: 30px; font-size: 22px;"}
:::{.columns}
:::{.column width="50%"}
- The [LEGB rule]{.alert} is a way to understand how Python looks for variables
- It stands for:
  - [Local]{.alert}: Variables defined inside a function
  - [Enclosing]{.alert}: Variables in the local scope of enclosing functions
  - [Global]{.alert}: Variables defined at the top level of a module
  - [Built-in]{.alert}: Predefined names in Python (e.g., `print`, `len`)
- Python will look for a variable in the [local scope]{.alert} first, then in the [enclosing functions]{.alert}, then in the [global scope]{.alert}, and finally in the [built-in scope]{.alert}
:::

:::{.column width="50%"}
```{python}
#| echo: true
#| eval: true
def outer_function():
    x = 10
    def inner_function():
        y = 5
        return x + y
    return inner_function()

print(outer_function())
```

- Here, `x` is in the [enclosing scope]{.alert} of `inner_function`, so it can access it
:::
:::
:::

## Appendix 06: `*args`: Packing Positional Arguments {#sec:appendix06}

:::{style="margin-top: 30px; font-size: 23px;"}
:::{.columns}
:::{.column width="50%"}
- Let's see something a bit more advanced! üòÖ
- `*args` and `**kwargs` are great tools for writing flexible functions

### `*args`:  Packing Positional Arguments

- What if you want a function that accepts a [variable number of positional arguments]{.alert}?
-  `*args` has got you covered!  It:
    -  Collects [extra positional arguments]{.alert} into a **tuple** called `args`
    -  Allows your function to be called with [any number of positional arguments]{.alert}
- Think of it as: `*args` = "arguments" (with a star to make it special!)
:::

:::{.column width="50%"}
:::{style="font-size: 18px;"}
```{python}
#| echo: true
#| eval: true
def make_pizza(*toppings): 
    print("Making a pizza with the following toppings:")
    for topping in toppings: 
        print(f"- {topping}")

make_pizza("pepperoni", "mushrooms")
```

:::{style="margin-top: 10px;"}
:::
```{python}
#| echo: true
#| eval: true
make_pizza("cheese", "onions", "olives", "sausage")
```

:::{style="margin-top: 10px;"}
:::
```{python}
#| echo: true
#| eval: true
make_pizza() # Still works!
```

:::
:::
:::
:::

## Appendix 07: `**kwargs`: Packing Keyword Arguments {#sec:appendix07}

:::{style="margin-top: 30px; font-size: 22px;"}
-  Similarly, `**kwargs` handles a [variable number of keyword arguments]{.alert}!
- Collects [extra keyword arguments]{.alert} into a **dictionary** called `kwargs`

```{python}
#| echo: true
#| eval: true
def user_profile(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

user_profile(name="Alice", age=30, city="Wonderland")
```

```{python}
#| echo: true
#| eval: true
user_profile(occupation="Coder", hobby="Python", level="Beginner")
```

- Inside the function, `kwargs` is a dictionary! Access arguments by key
- [Importanrt]{.alert}: `*args` must come before `**kwargs` in the function definition
:::